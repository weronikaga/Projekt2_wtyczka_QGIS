# -*- coding: utf-8 -*-
"""
/***************************************************************************
 wtyczka_QGISDialog
                                 A QGIS plugin
 Wtyczka do obliczeń na wybranej warstwie
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-06-04
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Weronika_Garbacz/Emilia_Bartnik
        email                : 01179134@pw.edu.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


import os
import csv
from math import *
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import Qgis, QgsProject, QgsWkbTypes, QgsPointXY, QgsGeometry, QgsVectorLayer, QgsFields, QgsField, QgsWkbTypes, QgsFeature
from qgis.utils import iface
from PyQt5.QtCore import QVariant
from qgis.PyQt.QtWidgets import QFileDialog, QInputDialog
from PyQt5.QtWidgets import QMessageBox
from PyQt5.QtWidgets import QTableWidgetItem


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'wtyczka_projekt_2_dialog_base.ui'))


class wtyczka_QGISDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(wtyczka_QGISDialog, self).__init__(parent)
        self.tableWidget = QtWidgets.QTableWidget()
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.licz_przewyzszenie.clicked.connect(self.calculate_dh)
        self.licz_powierzchnie.clicked.connect(self.pole)
        self.rysuj_poligon.clicked.connect(self.poligon)
        self.wyczysc_wyniki.clicked.connect(self.clear_console)
        self.odznacz_wszystko.clicked.connect(self.clear_selection)
        self.wynik_m2.clicked.connect(self.zmien_jednostke_pole)
        self.wynik_ha.clicked.connect(self.zmien_jednostke_pole)
        self.wynik_a.clicked.connect(self.zmien_jednostke_pole)
        self.wczytaj_plik.clicked.connect(self.wczytaj)
        self.wybierz_pkt.clicked.connect(self.wybierz_punkty)
        
        
    def calculate_dh(self):
        selected_layer = self.mMapLayerComboBox.currentLayer()
        if not selected_layer:
            iface.messageBar().pushMessage('Błąd - Nie wybrano warstwy', level=Qgis.Warning)
            return
        features = selected_layer.selectedFeatures()
        if len(features) != 2:
            iface.messageBar().pushMessage('Błąd - Należy wybrać dokładnie dwa punkty', level=Qgis.Warning)
            return
        try:
            h_1 = float(features[0]['wysokosc'])
            h_2 = float(features[1]['wysokosc'])
        except KeyError:
            iface.messageBar().pushMessage('Bład - Brak atrybuty "wysokosc" przy wybranych punktach', level=Qgis.Warning)
            return
        
        try:
            lista_nazwa = []
        
            # Iterate through the list of QgsFeature objects
            for feature in features:
                # Use the attribute method to get the value of "nr_punktu"
                nazwa = feature.attribute("nr_punktu")
                
                if nazwa is not None:
                    lista_nazwa.append(nazwa)
            
            # Ensure lista_nazwa has at least two elements
            if len(lista_nazwa) < 2:
                raise IndexError("Not enough elements in lista_nazwa")
            
            p_1 = int(lista_nazwa[0])
            p_2 = int(lista_nazwa[1])
        except IndexError:
            iface.messageBar().pushMessage('Błąd - Niewystarczająca liczba elementów w lista_nazwa', level=Qgis.Warning)
            return
        except ValueError:
            iface.messageBar().pushMessage('Błąd - Nie można przekonwertować wartości na int', level=Qgis.Warning)
            return

        
        dh = round(h_2 - h_1, 3)
        self.wynik.setText(f'Różnica wysokoci między punktami o numerach {p_1} a {p_2} punktami wynosi: {dh} m')
        iface.messageBar().pushMessage("Różnica wysokoci", f"Różnica wysokoci między puunktami o numerach {p_1} a {p_2} punktami wynosi: {dh} m")
        
        
        
    # def calculate_area(self):
    #     selected_layer = self.mMapLayerComboBox.currentLayer()
    #     features = selected_layer.selectedFeatures()
    #     x = float(features[0]['wysokosc'])
    #     y = float(features[1]['wysokosc'])
        
        
    def punkty(self):

        selected_layer = self.mMapLayerComboBox.currentLayer()
        if not selected_layer:
            iface.messageBar().pushMessage('Błąd - Nie wybrano warstwy', level=Qgis.Warning)
            return
        selected_features = selected_layer.selectedFeatures()
        
        pkt = []
        for feature in selected_features:
            feature_geometry = feature.geometry().asPoint()
            x = feature_geometry[0]
            y = feature_geometry[1]
            pkt.append([float(x), float(y)])
        
        pkt = self.sortuj_punkty(pkt)
        return pkt
        
    def pole(self):
        selected_layer = self.mMapLayerComboBox.currentLayer()
        if not selected_layer:
            iface.messageBar().pushMessage('Błąd - Nie wybrano warstwy', level=Qgis.Warning)
            return
        features = selected_layer.selectedFeatures()
        if len(features) < 3:
            iface.messageBar().pushMessage('Błąd - Należy wybrać dokładnie 3 punkty', level=Qgis.Warning)
            return
        selected_features = self.mMapLayerComboBox.currentLayer().selectedFeatures()
        
        str_punkty = len(features) 
        
        pkt = []
        nazwy_pkt = []
        id_pkt = []
        for feature in selected_features:
            feature_geometry = feature.geometry()
            if feature_geometry.isEmpty() or QgsWkbTypes.geometryType(feature_geometry.wkbType()) != QgsWkbTypes.PointGeometry:
                iface.messageBar().pushMessage("Błąd - Wybrany obiekt nie jest punktem", level=Qgis.Warning)
                return
            punkt = feature_geometry.asPoint()
            pkt.append(QgsPointXY(punkt.x(), punkt.y()))
            id_pkt.append(feature.id())
            nazwa = feature.attribute("nr_punktu")
            if nazwa is not None:
                nazwy_pkt.append(str(nazwa))  # Ensure nazwa is a string
            else:
                nazwy_pkt.append(f"Point {feature.id()}")
                
        pole = self.gauss(pkt)
        pole_1 = round(pole, 3)
        nazwy_str = ', '.join(nazwy_pkt)
        iface.messageBar().pushMessage("Wynik", f"Powierzchnia wielokąta o wierzchołkach w punkatch {nazwy_str} wynosi: {pole_1}", level=Qgis.Success)
        self.wynik.setText(f"Powierzchnia wielokąta o wierzchołkach w punkatch {nazwy_str} wynosi: {pole_1} m^2".format(pole))
        return (pole, str_punkty)
        
    def gauss(self, pkt):
        n = len(pkt)
        pole = 0.0
        
        for i in range(n):
            x1, y1 = pkt[i].x(), pkt[i].y()
            x2, y2 = pkt[(i + 1) % n].x(), pkt[(i + 1) % n].y()
            pole += x1 * y2 - x2 * y1
        return abs(pole) / 2
    
    def poligon(self):
        xy = self.punkty()
        if len(xy) < 3:
            iface.messageBar().pushMessage("Błąd - Wybrany obiekt nie jest punktem", level=Qgis.Warning)
            return
    
        punkty = [QgsPointXY(point[0], point[1]) for point in xy]
        punkty.append(punkty[0])

        pol_geom = QgsGeometry.fromPolygonXY([punkty])
        
        if not pol_geom.isGeosValid():
            self.wynik.setText('Nieprawidłowa geometria poligonu')
            return
        
        crs = self.mMapLayerComboBox.currentLayer().crs()
        poligon = QgsVectorLayer("Polygon?crs=" + crs.toWkt(), "poligon", "memory")
        
        if not poligon.isValid():
            self.wynik.setText('Nie udało się utworzyć warstwy poligonowej')
            return
        
        pol_provider = poligon.dataProvider()

        pol_fields = QgsFields()
        pol_fields.append(QgsField("nazwa", QVariant.String))
    
        pol_provider.addAttributes(pol_fields)
    
        poligon.updateFields()
        
        pol_feature = QgsFeature(pol_fields)
        pol_feature.setGeometry(pol_geom)
    
        if not pol_provider.addFeature(pol_feature):
            self.label_poligon.setText('Nie udało się dodać funkcji do warstwy poligonowej')
    
        QgsProject.instance().addMapLayer(poligon)
    
        #self.canvas.refresh()
        iface.messageBar().pushMessage("Poligon został utworzony", level=Qgis.Info)
        #self.label_poligon.setText('Poligon utworzony')
        
        
    def sortuj_punkty(self, xy):
        punkt_ref = [sum(p[0] for p in xy) / len(xy), sum(p[1] for p in xy) / len(xy)]
        xy_sort = sorted(xy, key=lambda p: self.dobierz_kat(p, punkt_ref))
        return xy_sort
    
    def dobierz_kat(self, p, punkt_ref):
        dx = p[0] - punkt_ref[0]
        dy = p[1] - punkt_ref[1]
        kat = atan2(dy,dx)
        return kat
    
    
    def clear_console(self):
        iface.messageBar().clearWidgets()
        self.wynik.clear()
        self.wynik_m.setChecked(False)
        self.wynik_ha.setChecked(False)
        self.wynik_a.setChecked(False)
        self.wynik_m2.setChecked(False)
        
    def clear_selection(self):
        layer = self.mMapLayerComboBox.currentLayer()
        if layer is not None:
            layer.removeSelection()
            
            
    def zmien_jednostke_pole(self):
        pole_m, punkty_str = self.pole()
        if self.wynik_a.isChecked():
            pole_a = pole_m/100
            self.wynik.setText(f'{pole_a:.3f} [a]')
            wynik_str = f'Pole powierzchni figury o wybranych {punkty_str} wierzchołkach wynosi: {pole_a:.3f} [a]'
        elif self.wynik_ha.isChecked():
            pole_ha = pole_m /10000
            self.wynik.setText(f'{pole_ha:.3f} [ha]')
            wynik_str = f'Pole powierzchni figury o wybranych {punkty_str} wierzchołkach wynosi: {pole_ha:.3f} [ha]'
        elif self.wynik_m2 .isChecked():
            self.wynik.setText(f'{pole_m:.3f} [m2]')
            wynik_str = f'Pole powierzchni figury o wybranych {punkty_str} wierzchołkach wynosi: {pole_m:.3f} [m2]'
        else:
            self.wynik.setText(f'{pole_m:.3f} [m2]')
            wynik_str = f'Pole powierzchni figury o wybranych {punkty_str} wierzchołkach wynosi: {pole_m:.3f} [m2]'
        iface.messageBar().pushMessage("Wynik", wynik_str, level=Qgis.Info)
    
    def wybierz_punkty(self):
        # Pobierz listę warstw dostępnych w projekcie QGIS
        layers = QgsProject.instance().mapLayers().values()
        
        # Utwórz listę nazw warstw
        layer_names = [layer.name() for layer in layers]
        
        # Zwróć listę warstw, jeśli nie ma żadnych warstw, wyświetl komunikat i zakończ funkcję
        if not layer_names:
            iface.messageBar().pushMessage('Brak warstw w projekcie', level=Qgis.Warning)
            return
        
        # Wyświetl okno dialogowe z listą warstw
        selected_layer_name, ok = QInputDialog.getItem(self, "Wybierz warstwę", "Wybierz warstwę:", layer_names, 0, False)
        
        # Jeśli użytkownik anulował wybór lub nie wybrał żadnej warstwy, zakończ funkcję
        if not ok:
            return
        
        # Pobierz warstwę na podstawie wybranej nazwy
        selected_layer = QgsProject.instance().mapLayersByName(selected_layer_name)[0]
        
        # Sprawdź, czy warstwa została poprawnie pobrana
        if not selected_layer:
            iface.messageBar().pushMessage(f'Nie znaleziono warstwy o nazwie {selected_layer_name}', level=Qgis.Warning)
            return
        
        # Komunikat zachęcający do zaznaczenia nowych punktów
        iface.messageBar().pushMessage('Zaznacz nowe punkty na mapie', level=Qgis.Info)
        
        # Włączenie narzędzia do zaznaczania punktów na mapie
        iface.actionSelect().trigger()
        
        # Pobranie zaznaczonych punktów po zakończeniu zaznaczania
        features = selected_layer.selectedFeatures()
        if len(features) == 0:
            iface.messageBar().pushMessage('Błąd - Nie wybrano żadnych nowych punktów', level=Qgis.Warning)
            return
        
        selected_points = []
        for feature in features:
            point = feature.geometry().asPoint()
            selected_points.append((point.x(), point.y()))
        
        # Możesz teraz wykorzystać listę selected_points do dalszego przetwarzania
        # np. wyświetlenia, zapisania lub analizy nowych punktów
        
        # Tutaj możesz dodać kod do obsługi nowych punktów, np. wyświetlenie ich współrzędnych:
        coords_str = "\n".join([f"X: {point[0]}, Y: {point[1]}" for point in selected_points])
        QMessageBox.information(self, "Nowo zaznaczone punkty", f"Nowo zaznaczone punkty na warstwie {selected_layer_name}:\n{coords_str}")
    def wczytaj(self):
        uklad, ok = QInputDialog.getItem(self, "Wybierz układ współrzędnych", "Wybierz układ:", ["PL-1992", "PL-2000"], 0, False)
        if ok:
            dialog = QFileDialog()
            dialog.setFileMode(QFileDialog.AnyFile)
            dialog.setNameFilter("Dokumenty tekstowe (*.txt);;Pliki CSV (*.csv)")

            if not dialog.exec_():
                return
            wybrany_plik = dialog.selectedFiles()[0]
            
            if wybrany_plik.endswith(".txt"):
                with open(wybrany_plik, 'r') as plik:
                    lines = plik.readlines()
                    wiersze = [line.strip().split(' ') for line in lines]
        
            elif wybrany_plik.endswith(".csv"):
                with open(wybrany_plik, 'r') as plik:
                    csv_reader = csv.reader(plik)
                    wiersze = [row for row in csv_reader]
                
                
            if len(wiersze) == 0 or len(wiersze[0]) < 2:
                QMessageBox.warning(self, "Nieodpowiedni plik", "Wybrany plik ma więcej niż 2 kolumny danych.")
                return
            # Utworzenie tabeli o odpowiedniej liczbie wierszy i kolumn
            self.tableWidget.setRowCount(len(wiersze))
            self.tableWidget.setColumnCount(len(wiersze[0]))
                
                # Wypełnij tabelę danymi
            for i, wiersz in enumerate(wiersze):
                for j, wartosc in enumerate(wiersz):
                    p = QTableWidgetItem(wartosc)
                    self.tableWidget.setItem(i, j, p)
                    
            if uklad == "PL-1992":
                uklad_epsg = "EPSG:2180"
            elif uklad == "PL-2000":
                strefa, ok = QInputDialog.getItem(self, "Wybierz strefę PL-2000", "Wybierz strefę:", ["Strefa 5", "Strefa 6", "Strefa 7", "Strefa 8"], 0, False)
                if not ok:
                    return
                if strefa == "Strefa 5":
                    uklad_epsg = "EPSG:2176"
                elif strefa == "Strefa 6":
                    uklad_epsg = "EPSG:2177"
                elif strefa == "Strefa 7":
                    uklad_epsg = "EPSG:2178"
                elif strefa == "Strefa 8":
                    uklad_epsg = "EPSG:2179"
                
             # Dodanie warstwy do projektu QGIS
            uri = "Point?crs={}".format(uklad_epsg)
            layer = QgsVectorLayer(uri, "Nowa warstwa", "memory")
            provider = layer.dataProvider()
        
            for wiersz in wiersze:
                if wiersz[0] and wiersz[1]:  # Sprawdź, czy wartości nie są puste
                    try:
                        y = float(wiersz[0])
                        x = float(wiersz[1])
                        feature = QgsFeature()
                        point = QgsPointXY(x, y)
                        geometry = QgsGeometry.fromPointXY(point)
                        feature.setGeometry(geometry)
                        provider.addFeature(feature)
                    except ValueError:
                        QMessageBox.warning(self, "Błąd konwersji", "Wystąpił błąd podczas konwersji współrzędnych.")
        
            QgsProject.instance().addMapLayer(layer)