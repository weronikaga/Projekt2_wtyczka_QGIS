# -*- coding: utf-8 -*-
"""
/***************************************************************************
 wtyczka_QGISDialog
                                 A QGIS plugin
 Wtyczka do obliczeń na wybranej warstwie
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-06-04
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Weronika_Garbacz/Emilia_Bartnik
        email                : 01179134@pw.edu.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


import os
import csv
from math import *
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import Qgis, QgsProject, QgsWkbTypes, QgsPointXY, QgsGeometry, QgsVectorLayer, QgsFields, QgsField, QgsWkbTypes, QgsFeature
from qgis.utils import iface
from PyQt5.QtCore import QVariant
from qgis.PyQt.QtWidgets import QFileDialog, QInputDialog
from PyQt5.QtWidgets import QMessageBox
from PyQt5.QtWidgets import QTableWidgetItem


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'wtyczka_projekt_2_dialog_base.ui'))


class wtyczka_QGISDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(wtyczka_QGISDialog, self).__init__(parent)
        self.tableWidget = QtWidgets.QTableWidget()
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.licz_przewyzszenie.clicked.connect(self.licz_przewyzszenie)
        self.licz_powierzchnie.clicked.connect(self.pole)
        self.rysuj_poligon.clicked.connect(self.poligon)
        self.wyczysc_wyniki.clicked.connect(self.czysc_wynik)
        self.odznacz_wszystko.clicked.connect(self.czysc_wybor)
        self.wynik_m2.clicked.connect(self.zmien_jednostke_pola)
        self.wynik_ha.clicked.connect(self.zmien_jednostke_pola)
        self.wynik_a.clicked.connect(self.zmien_jednostke_pola)
        self.wczytaj_plik.clicked.connect(self.wczytaj)
        self.wybierz_pkt.clicked.connect(self.wybierz_punkty)
        
        
    def licz_przewyzszenie(self):
        """
        Funkcja licz_przewyzszenie oblicza różnicę wysokości między dwoma wybranymi punktami z warstwy w QGIS.
        
        Etapy działania funkcji:
        
        1. Pobranie wybranej warstwy z QGIS.
        2. Sprawdzenie, czy wybrano warstwę. Jeśli nie, wyświetla komunikat o błędzie.
        3. Pobranie wybranych cech (punktów) z warstwy.
        4. Sprawdzenie, czy wybrano dokładnie dwa punkty. Jeśli nie, wyświetla komunikat o błędzie.
        5. Pobranie wartości atrybutów 'wysokosc' dla obu punktów. Jeśli brakuje atrybutu, wyświetla komunikat o błędzie.
        6. Pobranie atrybutów 'nr_punktu' dla obu punktów i przekształcenie ich na wartości całkowite. Jeśli operacja się nie powiedzie, wyświetla odpowiedni komunikat o błędzie.
        7. Obliczenie różnicy wysokości (dh) między punktami.
        8. Wyświetlenie wyniku obliczeń w interfejsie użytkownika oraz jako komunikat w QGIS.
        
        Komunikaty błędów:
        - Błąd - Nie wybrano warstwy: jeśli nie wybrano żadnej warstwy.
        - Błąd - Należy wybrać dokładnie dwa punkty: jeśli nie wybrano dokładnie dwóch punktów.
        - Błąd - Brak atrybutu "wysokosc" przy wybranych punktach: jeśli brakuje atrybutu 'wysokosc' przy którymś z wybranych punktów.
        - Błąd - Niewystarczająca liczba elementów w lista_nazwa: jeśli nie uda się pobrać atrybutu 'nr_punktu' dla obu punktów.
        - Błąd - Nie można przekonwertować wartości na int: jeśli nie uda się przekształcić wartości 'nr_punktu' na liczbę całkowitą.
        
        Wynik:
        - Wyświetlenie różnicy wysokości (dh) między punktami w interfejsie użytkownika oraz jako komunikat w QGIS.
        """
        
        selected_layer = self.mMapLayerComboBox.currentLayer()
        if not selected_layer:
            iface.messageBar().pushMessage('Błąd - Nie wybrano warstwy', level=Qgis.Warning)
            return
        features = selected_layer.selectedFeatures()
        if len(features) != 2:
            iface.messageBar().pushMessage('Błąd - Należy wybrać dokładnie dwa punkty', level=Qgis.Warning)
            return
        try:
            h_1 = float(features[0]['wysokosc'])
            h_2 = float(features[1]['wysokosc'])
        except KeyError:
            iface.messageBar().pushMessage('Bład - Brak atrybuty "wysokosc" przy wybranych punktach', level=Qgis.Warning)
            return
        
        try:
            lista_nazwa = []
            for feature in features:
                nazwa = feature.attribute("nr_punktu")
                if nazwa is not None:
                    lista_nazwa.append(nazwa)
            if len(lista_nazwa) < 2:
                raise IndexError("Błąd - Niewystarczająca liczba elementów w lista_nazwa")
            
            p_1 = int(lista_nazwa[0])
            p_2 = int(lista_nazwa[1])
        except IndexError:
            iface.messageBar().pushMessage('Błąd - Niewystarczająca liczba elementów w lista_nazwa', level=Qgis.Warning)
            return
        except ValueError:
            iface.messageBar().pushMessage('Błąd - Nie można przekonwertować wartości na int', level=Qgis.Warning)
            return

        
        dh = round(h_2 - h_1, 3)
        self.wynik.setText(f'Różnica wysokoci między punktami o numerach {p_1} a {p_2} punktami wynosi: {dh} m')
        iface.messageBar().pushMessage("Różnica wysokoci", f"Różnica wysokoci między puunktami o numerach {p_1} a {p_2} punktami wynosi: {dh} m")
        
        
<<<<<<< HEAD
=======

        
        
>>>>>>> 74c939ca03b1b94bec5a5ca3b0b78fb534fff59d
    def punkty(self):
        """
         Funkcja punkty pobiera wybrane punkty z wybranej warstwy w QGIS, przetwarza ich współrzędne,
         a następnie sortuje i zwraca listę tych punktów.
         
         Etapy działania funkcji:
         
         1. Pobranie wybranej warstwy z QGIS.
         2. Sprawdzenie, czy wybrano warstwę. Jeśli nie, wyświetla komunikat o błędzie.
         3. Pobranie wybranych cech (punktów) z warstwy.
         4. Przetworzenie współrzędnych geometrycznych każdego punktu do listy [x, y].
         5. Dodanie przetworzonych współrzędnych do listy `pkt`.
         6. Sortowanie listy punktów przy użyciu metody `self.sortuj_punkty`.
         7. Zwrócenie posortowanej listy punktów.
         
         Komunikaty błędów:
         - Błąd - Nie wybrano warstwy: jeśli nie wybrano żadnej warstwy.
         
         Parametry:
         - self: Instancja klasy, w której znajduje się metoda.
         
         Zwraca:
         - pkt: Lista posortowanych punktów w formacie [[x1, y1], [x2, y2], ..., [xn, yn]].
         """

        selected_layer = self.mMapLayerComboBox.currentLayer()
        if not selected_layer:
            iface.messageBar().pushMessage('Błąd - Nie wybrano warstwy', level=Qgis.Warning)
            return
        selected_features = selected_layer.selectedFeatures()
        
        pkt = []
        for feature in selected_features:
            feature_geometry = feature.geometry().asPoint()
            x = feature_geometry[0]
            y = feature_geometry[1]
            pkt.append([float(x), float(y)])
        
        pkt = self.sortuj_punkty(pkt)
        return pkt
        
    def pole(self):
<<<<<<< HEAD
        """
        Funkcja pole oblicza powierzchnię wielokąta utworzonego z trzech wybranych punktów z warstwy w QGIS.
        
        Etapy działania funkcji:
        
        1. Pobranie wybranej warstwy z QGIS.
        2. Sprawdzenie, czy wybrano warstwę. Jeśli nie, wyświetla komunikat o błędzie.
        3. Pobranie wybranych cech (punktów) z warstwy.
        4. Sprawdzenie, czy wybrano dokładnie trzy punkty. Jeśli nie, wyświetla komunikat o błędzie.
        5. Inicjalizacja list `pkt`, `nazwy_pkt` i `id_pkt`.
        6. Przetworzenie geometrii wybranych punktów:
           - Sprawdzenie, czy geometria jest punktem. Jeśli nie, wyświetla komunikat o błędzie.
           - Pobranie współrzędnych punktu i dodanie ich do listy `pkt`.
           - Pobranie atrybutu "nr_punktu" i dodanie go do listy `nazwy_pkt`. Jeśli brak atrybutu, dodanie ID punktu jako nazwy.
        7. Obliczenie powierzchni wielokąta przy użyciu metody `self.gauss`.
        8. Zaokrąglenie wyniku powierzchni do trzech miejsc po przecinku.
        9. Wyświetlenie wyniku w interfejsie użytkownika oraz jako komunikat w QGIS.
        10. Zwrócenie obliczonej powierzchni oraz liczby punktów.
        
        Komunikaty błędów:
        - Błąd - Nie wybrano warstwy: jeśli nie wybrano żadnej warstwy.
        - Błąd - Należy wybrać dokładnie 3 punkty: jeśli nie wybrano dokładnie trzech punktów.
        - Błąd - Wybrany obiekt nie jest punktem: jeśli którykolwiek z wybranych obiektów nie jest punktem.
        
        Parametry:
        - self: Instancja klasy, w której znajduje się metoda.
        
        Zwraca:
        - tuple: Zawiera obliczoną powierzchnię wielokąta (pole) oraz liczbę wybranych punktów (str_punkty).
        """
        selected_layer = self.mMapLayerComboBox.currentLayer()
        if not selected_layer:
            iface.messageBar().pushMessage('Błąd - Nie wybrano warstwy', level=Qgis.Warning)
            return
        features = selected_layer.selectedFeatures()
        if len(features) < 3:
            iface.messageBar().pushMessage('Błąd - Należy wybrać dokładnie 3 punkty', level=Qgis.Warning)
            return
        selected_features = self.mMapLayerComboBox.currentLayer().selectedFeatures()
        
        str_punkty = len(features) 
        
        pkt = []
        nazwy_pkt = []
        id_pkt = []
        for feature in selected_features:
            feature_geometry = feature.geometry()
            if feature_geometry.isEmpty() or QgsWkbTypes.geometryType(feature_geometry.wkbType()) != QgsWkbTypes.PointGeometry:
                iface.messageBar().pushMessage("Błąd - Wybrany obiekt nie jest punktem", level=Qgis.Warning)
                return
            punkt = feature_geometry.asPoint()
            pkt.append(QgsPointXY(punkt.x(), punkt.y()))
            id_pkt.append(feature.id())
            nazwa = feature.attribute("nr_punktu")
            if nazwa is not None:
                nazwy_pkt.append(str(nazwa))  
            else:
                nazwy_pkt.append(f"Point {feature.id()}")
                
        pole = self.gauss(pkt)
        pole_1 = round(pole, 3)
        nazwy_str = ', '.join(nazwy_pkt)
        iface.messageBar().pushMessage("Wynik", f"Powierzchnia wielokąta o wierzchołkach w punkatch {nazwy_str} wynosi: {pole_1}", level=Qgis.Success)
        self.wynik.setText(f"Powierzchnia wielokąta o wierzchołkach w punkatch {nazwy_str} wynosi: {pole_1} m^2".format(pole))
        return (pole, str_punkty)
        
=======
            selected_layer = self.mMapLayerComboBox.currentLayer()
            if not selected_layer:
                iface.messageBar().pushMessage('Błąd - Nie wybrano warstwy', level=Qgis.Warning)
                return
            features = selected_layer.selectedFeatures()
            if len(features) < 3:
                iface.messageBar().pushMessage('Błąd - Należy wybrać dokładnie 3 punkty', level=Qgis.Warning)
                return
            selected_features = self.mMapLayerComboBox.currentLayer().selectedFeatures()
            
            str_punkty = len(features) 
            
            pkt = []
            nazwy_pkt = []
            id_pkt = []
            for feature in selected_features:
                feature_geometry = feature.geometry()
                if feature_geometry.isEmpty() or QgsWkbTypes.geometryType(feature_geometry.wkbType()) != QgsWkbTypes.PointGeometry:
                    iface.messageBar().pushMessage("Błąd - Wybrany obiekt nie jest punktem", level=Qgis.Warning)
                    return
                punkt = feature_geometry.asPoint()
                pkt.append(QgsPointXY(punkt.x(), punkt.y()))
                id_pkt.append(feature.id())
                nazwa = feature.attribute("nr_punktu")
                if nazwa is not None:
                    nazwy_pkt.append(str(nazwa))  # Ensure nazwa is a string
                else:
                    nazwy_pkt.append(f"Point {feature.id()}")
                    
            pole = self.gauss(pkt)
            pole_1 = round(pole, 3)
            nazwy_str = ', '.join(nazwy_pkt)
            iface.messageBar().pushMessage("Wynik", f"Powierzchnia wielokąta o wierzchołkach w punkatch {nazwy_str} wynosi: {pole_1}", level=Qgis.Success)
            self.wynik.setText(f"Powierzchnia wielokąta o wierzchołkach w punkatch {nazwy_str} wynosi: {pole_1} m^2".format(pole))
            return (pole, str_punkty)



>>>>>>> 74c939ca03b1b94bec5a5ca3b0b78fb534fff59d
    def gauss(self, pkt):
        """
        Funkcja gauss oblicza powierzchnię wielokąta na podstawie współrzędnych jego wierzchołków
        przy użyciu algorytmu Gaussa (wzoru na pole powierzchni wielokąta).
        
        Parametry:
        - self: Instancja klasy, w której znajduje się metoda.
        - pkt (list): Lista punktów wielokąta, gdzie każdy punkt jest instancją QgsPointXY i zawiera współrzędne x i y.
        
        Zwraca:
        - float: Powierzchnia wielokąta.
        
        Algorytm:
        1. Inicjalizacja zmiennej `pole` na wartość 0.0.
        2. Iteracja przez wszystkie punkty wielokąta.
        3. Dla każdego punktu obliczenie iloczynu współrzędnych z następnym punktem i aktualizacja zmiennej `pole`.
        4. Zwrócenie połowy wartości bezwzględnej zmiennej `pole`, co daje powierzchnię wielokąta.
        """
        n = len(pkt)
        pole = 0.0
        
        for i in range(n):
            x1, y1 = pkt[i].x(), pkt[i].y()
            x2, y2 = pkt[(i + 1) % n].x(), pkt[(i + 1) % n].y()
            pole += x1 * y2 - x2 * y1
        return abs(pole) / 2
    
    def poligon(self):
        """
        Funkcja poligon tworzy poligon na podstawie współrzędnych punktów wybranych z warstwy w QGIS, 
        a następnie dodaje go jako nową warstwę wektorową do projektu.
        
        Etapy działania funkcji:
        
        1. Pobranie współrzędnych punktów przy użyciu metody `punkty()`.
        2. Sprawdzenie, czy liczba punktów jest wystarczająca do utworzenia poligonu (co najmniej 3). Jeśli nie, wyświetla komunikat o błędzie.
        3. Utworzenie listy punktów `QgsPointXY` na podstawie współrzędnych i zamknięcie poligonu (dodanie pierwszego punktu na koniec listy).
        4. Utworzenie geometrii poligonu z listy punktów.
        5. Sprawdzenie, czy geometria poligonu jest prawidłowa. Jeśli nie, wyświetla komunikat o błędzie.
        6. Utworzenie nowej warstwy wektorowej typu poligon z odpowiednim układem współrzędnych (CRS).
        7. Sprawdzenie, czy warstwa poligonowa została poprawnie utworzona. Jeśli nie, wyświetla komunikat o błędzie.
        8. Dodanie atrybutów do nowej warstwy poligonowej.
        9. Utworzenie nowej cechy z geometrią poligonu i dodanie jej do warstwy.
        10. Sprawdzenie, czy cecha została poprawnie dodana do warstwy. Jeśli nie, wyświetla komunikat o błędzie.
        11. Dodanie nowej warstwy poligonowej do projektu QGIS.
        12. Wyświetlenie komunikatu o pomyślnym utworzeniu poligonu.
        
        Komunikaty błędów:
        - Błąd - Wybrany obiekt nie jest punktem: jeśli liczba punktów jest mniejsza niż 3.
        - Nieprawidłowa geometria poligonu: jeśli geometria utworzonego poligonu nie jest prawidłowa.
        - Nie udało się utworzyć warstwy poligonowej: jeśli nie uda się utworzyć nowej warstwy wektorowej typu poligon.
        - Nie udało się dodać funkcji do warstwy poligonowej: jeśli nie uda się dodać cechy (geometrii) do warstwy poligonowej.
        
        Parametry:
        - self: Instancja klasy, w której znajduje się metoda.
        """
        xy = self.punkty()
        if len(xy) < 3:
            iface.messageBar().pushMessage("Błąd - Wybrany obiekt nie jest punktem", level=Qgis.Warning)
            return
    
        punkty = [QgsPointXY(point[0], point[1]) for point in xy]
        punkty.append(punkty[0])

        pol_geom = QgsGeometry.fromPolygonXY([punkty])
        
        if not pol_geom.isGeosValid():
            self.wynik.setText('Nieprawidłowa geometria poligonu')
            return
        
        crs = self.mMapLayerComboBox.currentLayer().crs()
        poligon = QgsVectorLayer("Polygon?crs=" + crs.toWkt(), "poligon", "memory")
        
        if not poligon.isValid():
            self.wynik.setText('Nie udało się utworzyć warstwy poligonowej')
            return
        
        pol_provider = poligon.dataProvider()

        pol_fields = QgsFields()
        pol_fields.append(QgsField("nazwa", QVariant.String))
    
        pol_provider.addAttributes(pol_fields)
    
        poligon.updateFields()
        
        pol_feature = QgsFeature(pol_fields)
        pol_feature.setGeometry(pol_geom)
    
        if not pol_provider.addFeature(pol_feature):
            self.label_poligon.setText('Nie udało się dodać funkcji do warstwy poligonowej')
    
        QgsProject.instance().addMapLayer(poligon)
    
        iface.messageBar().pushMessage("Poligon został utworzony", level=Qgis.Info)
        
        
    def sortuj_punkty(self, xy):
        """
        Funkcja sortuj_punkty sortuje punkty w kolejności zgodnej z ruchem wskazówek zegara na podstawie kąta
        względem środka masy (centroidu) punktów.
        
        Parametry:
        - self: Instancja klasy, w której znajduje się metoda.
        - xy (list): Lista punktów w formacie [[x1, y1], [x2, y2], ..., [xn, yn]].
        
        Zwraca:
        - list: Lista punktów posortowanych w kolejności zgodnej z ruchem wskazówek zegara.
        
        Algorytm:
        1. Obliczenie współrzędnych centroidu (punkt_ref) jako średniej arytmetycznej współrzędnych x i y wszystkich punktów.
        2. Sortowanie listy punktów `xy` na podstawie kąta względem punktu odniesienia (punkt_ref) przy użyciu metody `self.dobierz_kat`.
        3. Zwrócenie posortowanej listy punktów.
        """
        punkt_ref = [sum(p[0] for p in xy) / len(xy), sum(p[1] for p in xy) / len(xy)]
        xy_sort = sorted(xy, key=lambda p: self.dobierz_kat(p, punkt_ref))
        return xy_sort
    
    def dobierz_kat(self, p, punkt_ref):
        """
        Funkcja dobierz_kat oblicza kąt między danym punktem a punktem odniesienia (centroidem) 
        względem osi X w układzie współrzędnych.
        
        Parametry:
        - self: Instancja klasy, w której znajduje się metoda.
        - p (list): Lista współrzędnych punktu w formacie [x, y].
        - punkt_ref (list): Lista współrzędnych punktu odniesienia (centroidu) w formacie [x, y].
        
        Zwraca:
        - float: Kąt (w radianach) między wektorem od punktu odniesienia do danego punktu a osią X.
        
        Algorytm:
        1. Obliczenie różnicy w współrzędnych x i y między danym punktem a punktem odniesienia.
        2. Obliczenie kąta przy użyciu funkcji `atan2` z biblioteki matematycznej, która zwraca kąt między wektorem a osią X.
        
        Uwagi:
        - Funkcja `atan2(dy, dx)` zwraca wartość kąta w zakresie od -π do π, co umożliwia rozróżnienie kierunków na płaszczyźnie.
        """
        dx = p[0] - punkt_ref[0]
        dy = p[1] - punkt_ref[1]
        kat = atan2(dy,dx)
        return kat
    
    
    def czysc_wynik(self):
        """
        Funkcja czysc_wynik resetuje widżety interfejsu użytkownika związane z wyświetlaniem wyników
        oraz czyści komunikaty w pasku wiadomości QGIS.
        
        Etapy działania funkcji:
        
        1. Usunięcie wszystkich widżetów z paska wiadomości QGIS przy użyciu `iface.messageBar().clearWidgets()`.
        2. Wyczyść pole tekstowe `self.wynik`.
        3. Odznaczenie opcji wyboru jednostek wyników: `self.wynik_m`, `self.wynik_ha`, `self.wynik_a`, `self.wynik_m2`.
        
        Parametry:
        - self: Instancja klasy, w której znajduje się metoda.
        
        Funkcja nie zwraca żadnych wartości.
        """
        iface.messageBar().clearWidgets()
        self.wynik.clear()
        self.wynik_m.setChecked(False)
        self.wynik_ha.setChecked(False)
        self.wynik_a.setChecked(False)
        self.wynik_m2.setChecked(False)
        
    def czysc_wybor(self):
        """
        Funkcja czysc_wybor usuwa zaznaczenie cech w bieżącej warstwie wybranej w QGIS.
        
        Etapy działania funkcji:
        
        1. Pobranie bieżącej warstwy z `mMapLayerComboBox`.
        2. Sprawdzenie, czy warstwa jest wybrana. Jeśli nie, funkcja kończy działanie.
        3. Usunięcie zaznaczenia wszystkich cech w bieżącej warstwie przy użyciu `layer.removeSelection()`.
        
        Parametry:
        - self: Instancja klasy, w której znajduje się metoda.
        
        Funkcja nie zwraca żadnych wartości.
        """
        layer = self.mMapLayerComboBox.currentLayer()
        if layer is not None:
            layer.removeSelection()
            
            
    def zmien_jednostke_pola(self):
        """
        Funkcja zmien_jednostke_pola przelicza pole powierzchni figury na różne jednostki (metry kwadratowe, ary, hektary)
        w zależności od wybranej opcji i wyświetla wynik w odpowiednim formacie.
        
        Etapy działania funkcji:
        
        1. Wywołanie metody `self.pole()` w celu obliczenia pola powierzchni figury w metrach kwadratowych oraz uzyskania liczby wierzchołków.
        2. Sprawdzenie, która z opcji wyboru jednostek (metry kwadratowe, ary, hektary) jest zaznaczona:
            - Jeśli zaznaczona jest opcja `wynik_a` (ary), przeliczenie pola na ary i ustawienie odpowiedniego tekstu.
            - Jeśli zaznaczona jest opcja `wynik_ha` (hektary), przeliczenie pola na hektary i ustawienie odpowiedniego tekstu.
            - Jeśli zaznaczona jest opcja `wynik_m2` (metry kwadratowe), ustawienie tekstu z polem w metrach kwadratowych.
            - Jeśli żadna opcja nie jest zaznaczona, ustawienie tekstu z polem w metrach kwadratowych jako domyślne.
        3. Wyświetlenie wyniku w odpowiednim polu tekstowym oraz w pasku wiadomości QGIS.
        
        Parametry:
        - self: Instancja klasy, w której znajduje się metoda.
        
        Funkcja nie zwraca żadnych wartości.
        """
        pole_m, punkty_str = self.pole()
        if self.wynik_a.isChecked():
            pole_a = pole_m/100
            self.wynik.setText(f'{pole_a:.3f} [a]')
            wynik_str = f'Pole powierzchni figury o wybranych {punkty_str} wierzchołkach wynosi: {pole_a:.3f} [a]'
        elif self.wynik_ha.isChecked():
            pole_ha = pole_m /10000
            self.wynik.setText(f'{pole_ha:.3f} [ha]')
            wynik_str = f'Pole powierzchni figury o wybranych {punkty_str} wierzchołkach wynosi: {pole_ha:.3f} [ha]'
        elif self.wynik_m2 .isChecked():
            self.wynik.setText(f'{pole_m:.3f} [m2]')
            wynik_str = f'Pole powierzchni figury o wybranych {punkty_str} wierzchołkach wynosi: {pole_m:.3f} [m2]'
        else:
            self.wynik.setText(f'{pole_m:.3f} [m2]')
            wynik_str = f'Pole powierzchni figury o wybranych {punkty_str} wierzchołkach wynosi: {pole_m:.3f} [m2]'
        iface.messageBar().pushMessage("Wynik", wynik_str, level=Qgis.Info)
    
    def wybierz_punkty(self):
<<<<<<< HEAD
        """
        Funkcja wybierz_punkty umożliwia użytkownikowi wybór warstwy z punktami w bieżącym projekcie QGIS
        i zaznaczenie nowych punktów na tej warstwie.
        
        Etapy działania funkcji:
        
        1. Pobranie wszystkich warstw z bieżącego projektu QGIS.
        2. Utworzenie listy nazw warstw.
        3. Sprawdzenie, czy istnieją warstwy w projekcie. Jeśli nie, wyświetlenie komunikatu o braku warstw i zakończenie funkcji.
        4. Wyświetlenie okna dialogowego umożliwiającego użytkownikowi wybór warstwy.
        5. Sprawdzenie, czy użytkownik dokonał wyboru warstwy. Jeśli nie, zakończenie funkcji.
        6. Pobranie wybranej warstwy na podstawie jej nazwy.
        7. Sprawdzenie, czy udało się pobrać warstwę o podanej nazwie. Jeśli nie, wyświetlenie komunikatu o błędzie i zakończenie funkcji.
        8. Wyświetlenie komunikatu o konieczności zaznaczenia nowych punktów na mapie.
        9. Aktywacja narzędzia zaznaczania punktów na warstwie.
        10. Pobranie wszystkich nowo zaznaczonych punktów na warstwie.
        11. Sprawdzenie, czy zaznaczono jakiekolwiek nowe punkty. Jeśli nie, wyświetlenie komunikatu o błędzie i zakończenie funkcji.
        12. Zapisanie współrzędnych nowo zaznaczonych punktów.
        13. Utworzenie komunikatu z informacją o nowo zaznaczonych punktach i ich współrzędnych oraz wyświetlenie go.
        
        Parametry:
        - self: Instancja klasy, w której znajduje się metoda.
        
        Funkcja nie zwraca żadnych wartości.
        """
        layers = QgsProject.instance().mapLayers().values()
    
        layer_names = [layer.name() for layer in layers]
    
        if not layer_names:
            iface.messageBar().pushMessage('Brak warstw w projekcie', level=Qgis.Warning)
            return
    
        selected_layer_name, ok = QInputDialog.getItem(self, "Wybierz warstwę", "Wybierz warstwę:", layer_names, 0, False)
        
        if not ok:
            return
        
        selected_layer = QgsProject.instance().mapLayersByName(selected_layer_name)[0]
        
=======
        
        layers = QgsProject.instance().mapLayers().values()
        
    
        layer_names = [layer.name() for layer in layers]
        
        
        if not layer_names:
            iface.messageBar().pushMessage('Brak warstw w projekcie', level=Qgis.Warning)
            return
        
 
        selected_layer_name, ok = QInputDialog.getItem(self, "Wybierz warstwę", "Wybierz warstwę:", layer_names, 0, False)
        

        if not ok:
            return
        

        selected_layer = QgsProject.instance().mapLayersByName(selected_layer_name)[0]
        

>>>>>>> 74c939ca03b1b94bec5a5ca3b0b78fb534fff59d
        if not selected_layer:
            iface.messageBar().pushMessage(f'Nie znaleziono warstwy o nazwie {selected_layer_name}', level=Qgis.Warning)
            return
        
<<<<<<< HEAD
        iface.messageBar().pushMessage('Zaznacz nowe punkty na mapie', level=Qgis.Info)
        
        iface.actionSelect().trigger()
        
=======

        iface.messageBar().pushMessage('Zaznacz nowe punkty na mapie', level=Qgis.Info)
        

        iface.actionSelect().trigger()
        
 
>>>>>>> 74c939ca03b1b94bec5a5ca3b0b78fb534fff59d
        features = selected_layer.selectedFeatures()
        if len(features) == 0:
            iface.messageBar().pushMessage('Błąd - Nie wybrano żadnych nowych punktów', level=Qgis.Warning)
            return
        
        selected_points = []
        for feature in features:
            point = feature.geometry().asPoint()
            selected_points.append((point.x(), point.y()))
<<<<<<< HEAD

        coords_str = "\n".join([f"X: {point[0]}, Y: {point[1]}" for point in selected_points])
        QMessageBox.information(self, "Nowo zaznaczone punkty", f"Nowo zaznaczone punkty na warstwie {selected_layer_name}:\n{coords_str}")
=======
        

        coords_str = "\n".join([f"X: {point[0]}, Y: {point[1]}" for point in selected_points])
        QMessageBox.information(self, "Nowo zaznaczone punkty", f"Nowo zaznaczone punkty na warstwie {selected_layer_name}:\n{coords_str}")
   
>>>>>>> 74c939ca03b1b94bec5a5ca3b0b78fb534fff59d
    
    def wczytaj(self):
        """
        Funkcja wczytaj umożliwia użytkownikowi wczytanie danych z pliku tekstowego lub CSV
        i wyświetlenie ich w tabeli, a następnie utworzenie warstwy punktowej na podstawie wczytanych danych.
        
        Etapy działania funkcji:
        
        1. Wyświetlenie okna dialogowego umożliwiającego użytkownikowi wybór układu współrzędnych.
        2. Wyświetlenie okna dialogowego do wyboru pliku tekstowego lub CSV.
        3. Sprawdzenie, czy użytkownik wybrał plik. Jeśli nie, zakończenie funkcji.
        4. W zależności od rozszerzenia pliku, wczytanie danych do listy `wiersze`.
        5. Sprawdzenie, czy wczytane dane zawierają co najmniej dwa wiersze i dwa punkty. Jeśli nie, wyświetlenie komunikatu o błędzie i zakończenie funkcji.
        6. Ustawienie liczby wierszy i kolumn w tabeli oraz wypełnienie jej danymi.
        7. W zależności od wybranego układu współrzędnych, przypisanie odpowiedniego EPSG do `uklad_epsg`.
        8. Utworzenie warstwy punktowej na podstawie wczytanych danych.
        9. Dodanie warstwy do bieżącego projektu QGIS.
        
        Parametry:
        - self: Instancja klasy, w której znajduje się metoda.
        
        Funkcja nie zwraca żadnych wartości.
        """
        uklad, ok = QInputDialog.getItem(self, "Wybierz układ współrzędnych", "Wybierz układ:", ["PL-1992", "PL-2000"], 0, False)
        if ok:
            dialog = QFileDialog()
            dialog.setFileMode(QFileDialog.AnyFile)
            dialog.setNameFilter("Dokumenty tekstowe (*.txt);;Pliki CSV (*.csv)")
    
            if not dialog.exec_():
                return
            wybrany_plik = dialog.selectedFiles()[0]
            
            if wybrany_plik.endswith(".txt"):
                with open(wybrany_plik, 'r') as plik:
                    lines = plik.readlines()
                    wiersze = [line.strip().split(' ') for line in lines]
        
            elif wybrany_plik.endswith(".csv"):
                with open(wybrany_plik, 'r') as plik:
                    csv_reader = csv.reader(plik)
                    wiersze = [row for row in csv_reader]
                
                
            if len(wiersze) == 0 or len(wiersze[0]) < 2:
                QMessageBox.warning(self, "Nieodpowiedni plik", "Wybrany plik ma więcej niż 2 kolumny danych.")
                return
<<<<<<< HEAD

=======
            
            # Utwórz tabelę atrybutów z nazwami kolumn "X", "Y" i "nr_punktu"
            self.tableWidget.setColumnCount(3)
            self.tableWidget.setHorizontalHeaderLabels(["X", "Y", "nr_punktu"])
            
            # Utworzenie tabeli o odpowiedniej liczbie wierszy i kolumn
>>>>>>> 74c939ca03b1b94bec5a5ca3b0b78fb534fff59d
            self.tableWidget.setRowCount(len(wiersze))
            self.tableWidget.setColumnCount(len(wiersze[0]) + 1)  # Dodajemy jedną kolumnę na nr_punktu
                
<<<<<<< HEAD
=======
            # Wypełnij tabelę danymi
>>>>>>> 74c939ca03b1b94bec5a5ca3b0b78fb534fff59d
            for i, wiersz in enumerate(wiersze):
                for j, wartosc in enumerate(wiersz):
                    p = QTableWidgetItem(wartosc)
                    self.tableWidget.setItem(i, j, p)
                # Ustaw numer punktu
                self.tableWidget.setItem(i, len(wiersze[0]), QTableWidgetItem(str(i+1)))
                    
            if uklad == "PL-1992":
                uklad_epsg = "EPSG:2180"
            elif uklad == "PL-2000":
                strefa, ok = QInputDialog.getItem(self, "Wybierz strefę PL-2000", "Wybierz strefę:", ["Strefa 5", "Strefa 6", "Strefa 7", "Strefa 8"], 0, False)
                if not ok:
                    return
                if strefa == "Strefa 5":
                    uklad_epsg = "EPSG:2176"
                elif strefa == "Strefa 6":
                    uklad_epsg = "EPSG:2177"
                elif strefa == "Strefa 7":
                    uklad_epsg = "EPSG:2178"
                elif strefa == "Strefa 8":
                    uklad_epsg = "EPSG:2179"
                
<<<<<<< HEAD
=======
            # Dodanie warstwy do projektu QGIS
>>>>>>> 74c939ca03b1b94bec5a5ca3b0b78fb534fff59d
            uri = "Point?crs={}".format(uklad_epsg)
            layer = QgsVectorLayer(uri, "Nowa warstwa", "memory")
            provider = layer.dataProvider()
            
            # Dodaj atrybuty x, y i nr_punktu do warstwy
            provider.addAttributes([QgsField("x", QVariant.Double), QgsField("y", QVariant.Double), QgsField("nr_punktu", QVariant.Int)])
            layer.updateFields()
        
<<<<<<< HEAD
            for wiersz in wiersze:
                if wiersz[0] and wiersz[1]: 
=======
            for i, wiersz in enumerate(wiersze):
                if wiersz[0] and wiersz[1]:  # Sprawdź, czy wartości nie są puste
>>>>>>> 74c939ca03b1b94bec5a5ca3b0b78fb534fff59d
                    try:
                        y = float(wiersz[0])
                        x = float(wiersz[1])
                        feature = QgsFeature()
                        point = QgsPointXY(x, y)
                        geometry = QgsGeometry.fromPointXY(point)
                        feature.setGeometry(geometry)
                        
                        # Dodaj współrzędne jako atrybuty
                        feature.setAttributes([x, y, i+1])
                        
                        provider.addFeature(feature)
                    except ValueError:
                        QMessageBox.warning(self, "Błąd konwersji", "Wystąpił błąd podczas konwersji współrzędnych.")
            
            QgsProject.instance().addMapLayer(layer)
